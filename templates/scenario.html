{% extends "base.html" %}

{% block title %}
Delamain Corporation - Scenario {{ scenario.id }}
{% endblock %}

{% block content %}
<style>
        #map {
            height: 66.67vh;
        }
        /* Dark Mode Styles */
    body {
        padding: 0;
        margin: 0;
    }

    /* Apply filters only for dark-tiles to differentiate light and dark themes */
    .dark-tiles {
        filter: invert(100%) hue-rotate(180deg) brightness(95%) contrast(90%);
    }
</style>

<div class="container">
    <h2 class="subtitle">Scenario: {{ scenario.id }} with {{ scenario.vehicles|length }} Vehicles
                and {{ scenario.customers|length }} Customers</h2>

    <button
            onclick="startLoop()" id="scenario_run_btn"
            class="button mb-3 ml-3">Start Scenario</button>
    <input type="range" value="50" min="1" max="100" id="sliderWithValue" oninput="document.getElementById('sliderID').innerHTML = this.value / 100">
    <label id="sliderID">0.5</label>
    <div id="map"></div>
<div class="legend" style="padding: 20px 0 20px 20px;">
    <h2>Legend</h2>
    <p><span style="display: inline-block; width: 20px; height: 10px; background-color: #EEA53A;"></span> Yellow Line: Ride in Progress</p>
    <p><span style="display: inline-block; width: 20px; height: 10px; background-color: #423BC4;"></span> Blue Line: Customer Destination Path</p>
    <p><img src="{{ url_for('static', filename='images/ready.png') }}" alt="Taxi" style="width: 20px;"> Blue Car: Available Vehicle</p>
    <p><img src="{{ url_for('static', filename='images/full.png') }}" alt="Taxi" style="width: 20px; filter: hue-rotate(330deg);"> Pink Car: Vehicle with Customer</p>
    <p><img src="{{ url_for('static', filename='images/person.png') }}" alt="Customer" style="width: 15px; filter: hue-rotate(330deg);"> Customer waiting for Taxi</p>
</div>
</div>

<!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin="">
</script>

<script>

    // Initialize the map
    var map = L.map('map').setView([{{ centerX }}, {{ centerY }}], 12);

    // Define the light and dark tile layers
    var lightTiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    });

    var darkTiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        className: 'dark-tiles' // Added a class name to apply filter styling to the dark map tiles
    });

    // Set the default tiles (light mode)
    lightTiles.addTo(map);

    // JavaScript for toggling sun/moon icon and dark/light theme
    const themeToggle = document.getElementById('theme-toggle');
    const htmlElement = document.documentElement;

    themeToggle.addEventListener('click', () => {
        if (htmlElement.getAttribute('data-theme') === 'light') {
            htmlElement.setAttribute('data-theme', 'dark');
            themeToggle.innerHTML = '&#9728;'; // Sun symbol
            map.removeLayer(lightTiles);
            darkTiles.addTo(map); // Add dark map tiles
        } else {
            htmlElement.setAttribute('data-theme', 'light');
            themeToggle.innerHTML = '&#9790;'; // Moon symbol
            map.removeLayer(darkTiles);
            lightTiles.addTo(map); // Add light map tiles
        }
    });

    var customIconTaxi = L.icon({
        iconUrl: "{{ url_for('static', filename='images/ready.png') }}",
        iconSize: [40, 40],
        iconAnchor: [20, 20],
        popupAnchor: [0, -20]
    });

    var customIconCustomer = L.icon({
        iconUrl: "{{ url_for('static', filename='images/person.png') }}",
        iconSize: [26, 40],
        iconAnchor: [13, 20],
        popupAnchor: [0, -20]
    });

    var vehicles = {{ scenario.vehicles|tojson }};
    var vehicleMap = {};
    for (const vehicle of vehicles) {
        var marker = L.marker([vehicle.coordX, vehicle.coordY], {icon: customIconTaxi});
        marker.addTo(map)
            .bindPopup(`<b>Vehicle:</b> ${vehicle.id}<br><b>Coordinates:</b> ${vehicle.coordX}, ${vehicle.coordY}`);
        vehicleMap[vehicle.id] = marker
    }


    var customers = {{ scenario.customers|tojson }};
    var customerMap = {};
    for (const customer of customers) {
        marker = L.marker([customer.coordX, customer.coordY], {icon: customIconCustomer});
        marker.addTo(map)
            .bindPopup(`<b>Customer:</b> ${customer.id}<br><b>Coordinates:</b> ${customer.coordX}, ${customer.coordY}`);
        customerMap[customer.id] = marker;
        L.polyline([[customer.coordX, customer.coordY], [customer.destinationX, customer.destinationY]], {color: "#423BC4FF"}).addTo(map);
    }
    var lines = {}
    var refreshIntervalId
    var lastAssigned = null

    async function startLoop() {
        var slider_val = document.getElementById("sliderWithValue").value
        var response = await fetch('{{ url_for("launch_scenario", id=scenario.id) }}', {method: "POST", headers: {
            "speed": slider_val / 100,
            },
        });
        var start_btn = document.getElementById("scenario_run_btn")
        start_btn.outerHTML = await response.text()
        await fetch('{{ url_for("assign", id=scenario.id) }}')
        refreshIntervalId = window.setInterval(updateMap, 500);
    }
    function updateMap() {
        var request = new XMLHttpRequest()
        request.open("get", '{{ url_for("get_scenario", id=scenario.id) }}', false)
        request.onreadystatechange = function() {
            if (this.readyState === 4 && this.status === 200) {
                var response = JSON.parse(this.responseText);
                try {
                if (response.customers.find(c => c.awaitingService) === undefined) {
                    console.log("DONE!")
                    clearInterval(refreshIntervalId);
                }
                var alreadyMatchedCustomerIds = new Set(response.vehicles.map(v => v.customerId));


                if (response.vehicles.find(v => v.isAvailable) && response.customers.find(c => c.awaitingService) && (lastAssigned == null || lastAssigned < (Date.now() - 4000))) {
                    console.log("Assigning, because " + response.customers.filter(c => c.awaitingService && !alreadyMatchedCustomerIds.has(c.id)).length + " are still missing")
                    var request = new XMLHttpRequest()
                    request.open("get", '{{ url_for("assign", id=scenario.id) }}', false)
                    request.send()
                    lastAssigned = Date.now()
                }
                for (const vehicle of response.vehicles) {
                    //console.log(vehicle.vehicleSpeed)
                    //console.log(vehicle.remainingTravelTime)
                    if (vehicle.customerId != null && lines[vehicle.id] == null) {
                        var line = L.polyline([L.latLng(vehicle.coordX, vehicle.coordY), customerMap[vehicle.customerId].getLatLng()], {color: '#EEA53AFF'}).addTo(map);
                        //console.log(line);
                        lines[vehicle.id] = line;
                    }
                    //if (vehicle.customerId != null && L.latLng(vehicle.coordX, vehicle.coordY).equals(customerMap[vehicle.customerId].getLatLng())) {
                    //    lines[vehicle.id] = null
                    //}
                    if (vehicle.customerId == null) {
                        lines[vehicle.id] = null
                    }
                    //vehicleMap[vehicle.id].setLatLng([vehicle.coordX, vehicle.coordY]).update()
                    var assignedCustomer = undefined
                    for (const customer of response.customers) {
                        if (customer.id == vehicle.customerId) {
                            assignedCustomer = customer;
                            break;
                        }
                    }
                    if (assignedCustomer != undefined) {
                        if (assignedCustomer.coordX == vehicle.coordX && assignedCustomer.coordY == vehicle.coordY) {// customer auf Taxi, distance zusammen updaten
                            var remaining_distance = vehicle.remainingTravelTime * vehicle.vehicleSpeed / 90000
                            var totalDistance = Math.pow(Math.pow((assignedCustomer.coordX - assignedCustomer.destinationX), 2) + Math.pow((assignedCustomer.coordY - assignedCustomer.destinationY), 2), 0.5)
                            var propotion = 1 - remaining_distance / totalDistance
                            if (propotion == 0)
                                propotion = 0
                            console.log(propotion)
                            var newX = (assignedCustomer.destinationX - vehicle.coordX) * propotion + vehicle.coordX
                            var newY = (assignedCustomer.destinationY - vehicle.coordY) * propotion + vehicle.coordY
                            vehicleMap[vehicle.id].setLatLng([newX, newY]).update()
                            customerMap[vehicle.customerId].setLatLng([newX, newY]).update()
                        } else {
                            var remaining_distance = vehicle.remainingTravelTime * vehicle.vehicleSpeed / 90000
                            var totalDistance = Math.pow(Math.pow((assignedCustomer.coordX - vehicle.coordX), 2) + Math.pow((assignedCustomer.coordY - vehicle.coordY), 2), 0.5)
                            //console.log(remaining_distance * 68884 / totalDistance)
                            var propotion = 1 - remaining_distance / totalDistance
                            if (propotion == 0)
                                propotion = 0
                            console.log(propotion)
                            var newX = (assignedCustomer.coordX - vehicle.coordX) * propotion + vehicle.coordX
                            var newY = (assignedCustomer.coordY - vehicle.coordY) * propotion + vehicle.coordY
                            vehicleMap[vehicle.id].setLatLng([newX, newY]).update()
                        }
                    }
                }
            } catch (e) {
                    console.log(e);
                clearInterval(refreshIntervalId)
            }
        }

        };
        request.send();

    }
</script>
{% endblock %}